ggtitle(paste("Exit Velocity vs Launch Angle of", "Shohei, Ohtani")) +
scale_x_continuous(name = "Launch Angle (deg)", breaks = seq(-40, 80, by = 10)) +
scale_y_continuous(name = "Scaled Exit Velocity (mph)", breaks = seq(0.4, 1.2, by = 0.2)) +
annotate(geom = "text", label = top_10_data$launch_angle[which.max(predict(quadratic_fit))], x = top_10_data$launch_angle[which.max(predict(quadratic_fit))], y = 1.2, vjust = 1)
}
plot_events_ev_vs_la("Ohtani, Shohei")
plot_events_ev_vs_la("Jose, Altuve")
plot_events_ev_vs_la("Altuve, Jose")
knitr::opts_chunk$set(echo = TRUE)
#Import packages
library(ggplot2)
library(dplyr)
library(ggrepel)
library(metR)
#Constants:
pitch_speed = 84.8 #mph
descent_angle = 8.0 #degrees
bat_speed = 73.0 #mph
attack_angle = 12.0 #degrees
pitch_spin = -2000 #rpm
mball = 5.125 #oz
mbat = 31.494 #oz
rball = 1.452 #in
rbat = 1.267 #in
gamma = descent_angle * pi / 180 #rad
psi = attack_angle * pi / 180 #rad
mu = 0.5500
alpha = 0.400
mbateff_x = 7.817 #oz
recoilx = 2 / 7 * mball / mbateff_x
v0ball = pitch_speed * 5280 * 12 / 3600 #ft/s
v0bat = bat_speed * 5280 * 12 / 3600 #ft/s
mbateff_y = 23.172 #oz
recoily = mball / mbateff_y
ex = 0.300
eT = (ex - recoilx) / (1 + recoilx)
omegai = pitch_spin * pi / 30 #rad/s
#Function for obtaining data with offset as input
bat_ball <- function(offset) {
theta = asin(offset / (rball + rbat)) #rad
centerline_angle = theta * 180 / pi #degree
D = (rball + rbat) * sin(theta - psi) #inch
v0ball_perp = v0ball * cos(theta - gamma) #ft/s
v0bat_perp = v0bat * cos(theta - psi) #ft/s
ey = 0.58 - (v0ball_perp + v0bat_perp - 1055) / 14094
eA = (ey - recoily) / (1 + recoily)
v0ball_T = v0ball * sin(theta - gamma) #ft/s
v0bat_T = - v0bat * sin(theta - psi) #ft/s
mulim = 0.55
vfball_perp = v0ball_perp * eA + v0bat_perp * (1 + eA) #ft/s
vfball_T = v0ball_T * (1 - alpha * eT) / (1 + alpha) + rball * omegai * alpha * (1 + eT) / (1 + alpha) + v0bat_T * alpha * (1 + eT) / (1 + alpha) #ft/s
angle = atan(vfball_T / vfball_perp) + theta #rad
launch_angle = angle * 180 / pi # degrees
omegaf = omegai + (v0ball_T - vfball_T) / (alpha * rball) #rad / s
exit_speed = sqrt(vfball_perp^2 + vfball_T^2) / (5280 * 12 / 3600) #mph
exit_spin = omegaf * 30 / pi #rpm
df <- data.frame(offset = offset,
centerline_angle = centerline_angle,
D = D,
exit_speed = exit_speed,
exit_spin = exit_spin,
launch_angle = launch_angle,
v0ball_perp = v0ball_perp,
v0bat_perp = v0bat_perp,
ey = ey,
eA = eA,
v0ball_T = v0ball_T,
v0bat_T = v0bat_T,
omegaf = omegaf,
vfball_perp = vfball_perp,
vfball_T = vfball_T,
angle = angle)
return(df)
}
#Make new column with column names of data
columns <- c('offset', 'centerline_angle', 'D', 'exit_speed', 'exit_spin', 'launch_angle', 'v0ball_perp', 'v0bat_perp', 'ey', 'eA', 'v0ball_T', 'v0bat_T', 'omegaf', 'vfball_perp', 'vfball_T', 'angle')
df <- data.frame(matrix(nrow = 0, ncol = length(columns)))
colnames(df) = columns
#Offset values
offset_values = seq(0, 2.60, by = 0.05)
#Obtain data for every offset values
for (value in offset_values) {
new_df <- bat_ball(value)
df <- rbind(df, new_df)
}
#Function for obtaining data with center line angle and attack angle as parameters
get_data <- function(CA, AA) {
psi = AA * pi / 180 #rad
theta = CA / 180 * pi #rad
offset = sin(theta) * (rball + rbat) #inch
D = (rball + rbat) * sin(theta - psi) #inch
v0ball_perp = v0ball * cos(theta - gamma) #ft/s
v0bat_perp = v0bat * cos(theta - psi) #ft/s
ey = 0.58 - (v0ball_perp + v0bat_perp - 1055) / 14094
eA = (ey - recoily) / (1 + recoily)
v0ball_T = v0ball * sin(theta - gamma) #ft/s
v0bat_T = - v0bat * sin(theta - psi) #ft/s
mulim = 0.55
vfball_perp = v0ball_perp * eA + v0bat_perp * (1 + eA) #ft/s
vfball_T = v0ball_T * (1 - alpha * eT) / (1 + alpha) + rball * omegai * alpha * (1 + eT) / (1 + alpha) + v0bat_T * alpha * (1 + eT) / (1 + alpha) #ft/s
angle = atan(vfball_T / vfball_perp) + theta #rad
launch_angle = angle * 180 / pi # degrees
omegaf = omegai + (v0ball_T - vfball_T) / (alpha * rball) #rad / s
exit_speed = sqrt(vfball_perp^2 + vfball_T^2) / (5280 * 12 / 3600) #mph
exit_spin = omegaf * 30 / pi #rpm
df <- data.frame(AA = AA,
CA = CA,
offset = offset,
D = D,
exit_speed = exit_speed,
exit_spin = exit_spin,
launch_angle = launch_angle,
v0ball_perp = v0ball_perp,
v0bat_perp = v0bat_perp,
ey = ey,
eA = eA,
v0ball_T = v0ball_T,
v0bat_T = v0bat_T,
omegaf = omegaf,
vfball_perp = vfball_perp,
vfball_T = vfball_T,
angle = angle)
return(df)
}
get_data(3.16, 12)
#Make new column with column names of data
columns_AA_CA <- c('AA', 'CA', 'offset', 'D', 'exit_speed', 'exit_spin', 'launch_angle', 'v0ball_perp', 'v0bat_perp', 'ey', 'eA', 'v0ball_T', 'v0bat_T', 'omegaf', 'vfball_perp', 'vfball_T', 'angle')
data_AA_CA <- data.frame(matrix(nrow = 0, ncol = length(columns_AA_CA)))
colnames(data_AA_CA) = columns_AA_CA
#Offset values
offset_AA = seq(-10, 50, by = 0.5)
offset_CA = seq(-10, 40, by = 0.5)
#Obtain data for every offset values
for (AA in offset_AA) {
for (CA in offset_CA) {
new_data_AA_CA <- get_data(CA, AA)
data_AA_CA <- rbind(data_AA_CA, new_data_AA_CA)
}
}
#Function to filter launch angle
filter_data_LA <- function(LA) {
data_LA <- data_AA_CA %>%
filter(round(launch_angle) == LA)
return(data_LA)
}
length(filter_data_LA(0))
filter_data_LA(0)
filter_data_LA(0)[1, ]
data_AA_CA <- data_AA_CA %>%
mutate(scaled_ev = exit_speed / max(data_AA_CA$exit_speed),
scaled_ev = round(scaled_ev, 4))
ggplot(data_AA_CA, aes(CA, AA, z = exit_speed)) + geom_contour(binwidth = 1) +
geom_text_contour() + geom_abline(CA = AA) +
geom_smooth(data = filter_data_LA(0), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(10), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(20), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(30), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(40), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(50), se = FALSE, linetype = "dashed", color = "red") +
geom_text_repel(data = filter_data_LA(0)[nrow(filter_data_LA(0)), ], aes(label = paste("LA: ", round(launch_angle))), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(10)[nrow(filter_data_LA(10)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(20)[nrow(filter_data_LA(20)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(30)[nrow(filter_data_LA(30)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(40)[nrow(filter_data_LA(40)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(50)[nrow(filter_data_LA(50)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
labs(title = "Exit Velocity With Respect to Attack Angle and Centerline Angle") +
xlab("Centerline Angle (deg)") + ylab("Attack Angle (deg)")
plot1 <- ggplot(data_AA_CA, aes(CA, AA, z = scaled_ev)) + geom_contour(binwidth = 0.01) +
geom_text_contour(aes(label = round(..level.., 2))) +
geom_abline(CA = AA) +
geom_smooth(data = filter_data_LA(0), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(10), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(20), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(30), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(40), se = FALSE, linetype = "dashed", color = "red") +
geom_smooth(data = filter_data_LA(50), se = FALSE, linetype = "dashed", color = "red") +
geom_text_repel(data = filter_data_LA(0)[nrow(filter_data_LA(0)), ], aes(label = paste("LA: ", round(launch_angle))), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(10)[nrow(filter_data_LA(10)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(20)[nrow(filter_data_LA(20)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(30)[nrow(filter_data_LA(30)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(40)[nrow(filter_data_LA(40)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
geom_text_repel(data = filter_data_LA(50)[nrow(filter_data_LA(50)), ], aes(label = round(launch_angle)), color = "red", position = "identity") +
labs(title = "Exit Velocity With Respect to Attack Angle and Centerline Angle") +
xlab("Centerline Angle (deg)") + ylab("Attack Angle (deg)")
get_player_data <- function(player_name) {
data_player <- data_AA_CA %>%
filter(round(launch_angle) == round(as.numeric(la_for_peak_ev(player_name)[1])),
CA == AA) %>%
mutate(player_name = player_name)
return(data_player[1,])
}
top_hr_hitters <- c("Perez, Salvador", "Guerrero Jr., Vladimir","Ohtani, Shohei", "Semien, Marcus", "Tatis Jr., Fernando", "Judge, Aaron", "Olson, Matt", "Haniger, Mitch" ,"Lowe, Brandon", "Devers, Rafael")
top_avg_hitters <- c("Turner, Trea", "Gurriel, Yuli", "Soto, Juan", "Brantley, Michael", "Guerrero Jr., Vladimir", "Marte, Starling", "Harper, Bryce", "Anderson, Tim", "Castellanos, Nick", "Frazier, Adam")
get_player_df <- function(players) {
data_players <- get_player_data(top_hr_hitters[1])
for (i in 2: length(top_hr_hitters)) {
new_data_player <- get_player_data((top_hr_hitters[i]))
data_players <- rbind(data_players, new_data_player)
}
return(data_players)
}
plot1 + geom_point(data = get_player_df(top_hr_hitters), aes(CA, AA)) + geom_text_repel(data = get_player_df(top_hr_hitters), aes(label = player_name))
plot1 + geom_point(data = get_player_df(top_avg_hitters), aes(CA, AA)) + geom_text_repel(data = get_player_df(top_avg_hitters), aes(label = player_name))
plot1
#Function for plotting Exit Velocity vs Launch Angle for a batter
get_top_10_data <- function(batter) {
#Narrow data into Batter Name, Exit Velocity, and Launch Angle with non NA value
data_batter <- new_data2 %>%
select(player_name, scaled_ev, launch_speed, launch_angle) %>%
na.omit() %>%
#Label data with launch angle for every bins of width 5 degrees
filter(player_name == batter) %>%
mutate(theta5 = 5 * round(launch_angle / 5, 0)) %>%
arrange(launch_angle)
#Create data set of top 10 percent exit velocity within each bins
new_df <- data.frame(theta5 = 0, top_10_ev = 0)
for (theta in unique(data_batter$theta5)) {
n_data <- data_batter %>%
filter(theta5 == theta)
df <- data.frame(theta5 = theta, top_10_ev = quantile(n_data$scaled_ev, seq(0, 1, 1/10))[10])
new_df <- rbind(new_df, df)
}
new_df <- new_df[-c(1),]
data_batter <- inner_join(data_batter, new_df, by = "theta5")
top_10_data <- data_batter %>%
filter(scaled_ev >= top_10_ev,
launch_angle > -40) %>%
mutate(top_10 = "Yes")
return(top_10_data)
}
#Get closest data in excel
get_approx_data <- function(player) {
player_data <- get_top_10_data(player) %>%
filter(launch_angle >= min(data_AA_CA$launch_angle),
launch_angle <= max(data_AA_CA$launch_angle))
data_o <- data_AA_CA %>%
filter(launch_angle < 1 + player_data[1, ]$launch_angle,
launch_angle > -1 + player_data[1, ]$launch_angle)
data_oo <- data_o[which.min(abs(as.numeric(player_data[1, ]$scaled_ev)-data_o$scaled_ev)),]
for (i in 2:nrow(player_data)) {
new_data_o <- data_AA_CA %>%
filter(launch_angle < 1 + player_data[i, ]$launch_angle,
launch_angle > -1 + player_data[i, ]$launch_angle)
new_data_oo <- new_data_o[which.min(abs(as.numeric(player_data[i, ]$scaled_ev)-new_data_o$scaled_ev)),]
data_oo <- rbind(data_oo, new_data_oo)
}
return(data_oo)
}
plot1 + geom_point(data = get_approx_data("Ohtani, Shohei"), aes(CA, AA))
plot1 + geom_point(data = get_approx_data("Altuve, Jose"), aes(CA, AA))
AA_LA <- data_AA_CA %>%
filter(AA == CA) %>%
select(AA, launch_angle)
ggplot(AA_LA, aes(AA, launch_angle)) + geom_point() + geom_smooth()
View(data_AA_CA)
View(data_batter)
View(data_AA_CA)
View(new_data2)
View(new_data2)
View(data_AA_CA)
df <- sc_2021_FF %>%
select(play, release_speed, release_pos_z, release_pos_x_adj,
release_extension, pfx_x_adj, pfx_z, release_spin_rate,
spin_axis_adj, plate_x, plate_z)
#Libraries needed
library(tidyverse)
library(mgcv)
library(broom)
library(ggplot2)
library(ggpubr)
library(Lahman)
library(ranger)
library(caret)
library(retrosheet)
library(stringr)
library(vctrs)
library(rsample)
library(gbm)
library(ROCR)
#Import data
sc_2021 <- read_csv("C:/Users/12244/STAT430/statcast/2021.csv")
sc_2021_1 <- sc_2021 %>%
filter(description %in% c("hit_into_play", "swinging_strike", "swinging_strike_blocked"))
sc_2021_2 <- sc_2021_1 %>%
mutate(play = case_when(description == "hit_into_play" ~ 1,
description %in% c("swinging_strike", "swinging_strike_blocked") ~ 0,
TRUE ~ 0))
#Adjust horizontal data to account for R and L pitchers
sc_2021_3 <- sc_2021_2 %>%
mutate(release_pos_x_adj = ifelse(p_throws == "R", release_pos_x, - release_pos_x),
pfx_x_adj = ifelse(p_throws == "R", pfx_x, - pfx_x),
spin_axis_adj = ifelse(p_throws == "R", spin_axis, 360 - spin_axis)) %>%
filter(!is.na(release_speed),
!is.na(release_pos_z),
!is.na(release_pos_x_adj),
!is.na(release_extension),
!is.na(pfx_x_adj),
!is.na(pfx_z),
!is.na(release_spin_rate),
!is.na(spin_axis_adj)) %>%
mutate(play = as.factor(play))
sc_2021_FF <- sc_2021_3 %>%
filter(pitch_type == "FF")
#####################################################################################################
#####################################################################################################
#####################################################################################################
#####################################################################################################
################################Gradient Boost Model#################################################
#####################################################################################################
#####################################################################################################
#####################################################################################################
#####################################################################################################
df <- sc_2021_FF %>%
select(play, release_speed, release_pos_z, release_pos_x_adj,
release_extension, pfx_x_adj, pfx_z, release_spin_rate,
spin_axis_adj, plate_x, plate_z)
df$play <- as.logical(as.integer(df$play)-1)
set.seed(1234)
inTrain <- createDataPartition(y = df$play,
p = 7/10, list = FALSE)
Train <- df[inTrain,]
Test <- df[-inTrain,]
# model
SimpleGBMModel2 <- gbm(formula = play ~ . ,
distribution = "bernoulli",
data = Train,
n.trees = 1000,
#maximum depth of each tree
interaction.depth = 10,
#learning rate
shrinkage = 0.008,
cv.folds = 4)
ntree_opt_cv <- gbm.perf(SimpleGBMModel2, method = "cv")
print(ntree_opt_cv)
print(SimpleGBMModel2)
summary(SimpleGBMModel2)
Predictions <- predict(object = SimpleGBMModel2,
newdata = Test,
n.trees = ntree_opt_cv,
type = "response")
#Split Binaries into 0 and 1
PredictionsBinaries <- as.factor(ifelse(Predictions > 0.5, 1, 0))
Test$play <- as.factor(as.integer(Test$play))
#Display Confusion Matrix
confusionMatrix(PredictionsBinaries, Test$play)
##ROC Curve
#Calculate errors
GBM_pred_testing <- prediction(Predictions, Test$play)
#Create ROC curve data
GBM_ROC_testing <- performance(GBM_pred_testing, "tpr", "fpr")
#Plot ROC curve
plot(GBM_ROC_testing)
plot(GBM_ROC_testing, add=TRUE, col="green")
legend("right", legend=c("GBM"), col=c("green"), lty=1:2, cex = 0.6)
##AUC
#Create AUC data
auc.tmp <- performance(GBM_pred_testing, "auc")
#Calculate AUC
gbm_auc_testing <- as.numeric(auc.tmp@y.values)
#AUC score
gbm_auc_testing
summary(SimpleGBMModel2)
##############################################################################################
##############################################################################################
df <- sc_2021_FF %>%
select(play, release_speed, release_pos_z, release_pos_x_adj,
release_extension, pfx_x_adj, pfx_z, release_spin_rate,
spin_axis_adj, plate_x, plate_z)
df$play <- as.logical(as.integer(df$play)-1)
set.seed(1234)
inTrain <- createDataPartition(y = df$play,
p = 7/10, list = FALSE)
Train <- df[inTrain,]
Test <- df[-inTrain,]
# model
SimpleGBMModel <- gbm(formula = play ~ . ,
distribution = "bernoulli",
data = Train,
n.trees = 1000,
#maximum depth of each tree
interaction.depth = 10,
#learning rate
shrinkage = 0.008,
cv.folds = 4)
ntree_opt_cv <- gbm.perf(SimpleGBMModel, method = "cv")
print(ntree_opt_cv)
print(SimpleGBMModel)
summary(SimpleGBMModel)
Predictions <- predict(object = SimpleGBMModel,
newdata = Test,
n.trees = ntree_opt_cv,
type = "response")
#Split Binaries into 0 and 1
PredictionsBinaries <- as.factor(ifelse(Predictions > 0.5, 1, 0))
Test$play <- as.factor(as.integer(Test$play))
#Display Confusion Matrix
confusionMatrix(PredictionsBinaries, Test$play)
##ROC Curve
#Calculate errors
GBM_pred_testing <- prediction(Predictions, Test$play)
#Create ROC curve data
GBM_ROC_testing <- performance(GBM_pred_testing, "tpr", "fpr")
#Plot ROC curve
plot(GBM_ROC_testing)
plot(GBM_ROC_testing, add=TRUE, col="green")
legend("right", legend=c("GBM"), col=c("green"), lty=1:2, cex = 0.6)
##AUC
#Create AUC data
auc.tmp <- performance(GBM_pred_testing, "auc")
#Calculate AUC
gbm_auc_testing <- as.numeric(auc.tmp@y.values)
#AUC score
gbm_auc_testing
df2 <- sc_2021_FF %>%
select(play, release_speed, release_pos_z, release_pos_x_adj,
release_extension, pfx_x_adj, pfx_z, release_spin_rate,
spin_axis_adj)
df2$play <- as.logical(as.integer(df2$play)-1)
set.seed(1234)
inTrain2 <- createDataPartition(y = df2$play,
p = 7/10, list = FALSE)
Train2 <- df2[inTrain2,]
Test2 <- df2[-inTrain2,]
# model
SimpleGBMModel2 <- gbm(formula = play ~ . ,
distribution = "bernoulli",
data = Train2,
n.trees = 1000,
#maximum depth of each tree
interaction.depth = 10,
#learning rate
shrinkage = 0.008,
cv.folds = 4)
ntree_opt_cv2 <- gbm.perf(SimpleGBMModel2, method = "cv")
print(ntree_opt_cv2)
print(SimpleGBMModel2)
summary(SimpleGBMModel2)
Predictions2 <- predict(object = SimpleGBMModel2,
newdata = Test2,
n.trees = ntree_opt_cv2,
type = "response")
#Split Binaries into 0 and 1
PredictionsBinaries2 <- as.factor(ifelse(Predictions2 > 0.5, 1, 0))
Test2$play <- as.factor(as.integer(Test2$play))
#Display Confusion Matrix
confusionMatrix(PredictionsBinaries2, Test2$play)
##ROC Curve
#Calculate errors
GBM_pred_testing2 <- prediction(Predictions2, Test2$play)
#Create ROC curve data
GBM_ROC_testing2 <- performance(GBM_pred_testing2, "tpr", "fpr")
#Plot ROC curve
plot(GBM_ROC_testing2)
plot(GBM_ROC_testing2, add=TRUE, col="green")
legend("right", legend=c("GBM"), col=c("green"), lty=1:2, cex = 0.6)
##AUC
#Create AUC data
auc.tmp2 <- performance(GBM_pred_testing2, "auc")
#Calculate AUC
gbm_auc_testing2 <- as.numeric(auc.tmp2@y.values)
#AUC score
gbm_auc_testing2
summary(SimpleGBMModel2)
plot_events_ev_vs_la("Ohtani, Shohei")
#Function for plotting scaled exit velocity vs launch angle differentiating by events
plot_events_ev_vs_la <- function(batter) {
data_batter <- new_data2 %>%
#Label data with launch angle for every bins of width 5 degrees
filter(player_name == batter) %>%
mutate(theta5 = 5 * round(launch_angle / 5, 0)) %>%
arrange(launch_angle)
#Create data set of top 10 percent exit velocity within each bins
new_df <- data.frame(theta5 = 0, top_10_ev = 0)
for (theta in unique(data_batter$theta5)) {
n_data <- data_batter %>%
filter(theta5 == theta)
df <- data.frame(theta5 = theta, top_10_ev = quantile(n_data$scaled_ev, seq(0, 1, 1/10))[10])
new_df <- rbind(new_df, df)
}
new_df <- new_df[-c(1),]
data_batter <- inner_join(data_batter, new_df, by = "theta5")
top_10_data <- data_batter %>%
filter(scaled_ev >= top_10_ev,
launch_angle > -40) %>%
mutate(top_10 = "Yes")
#Join two data
combined_data <- left_join(data_batter, top_10_data, by = c("player_name", "scaled_ev", "launch_speed", "launch_angle", "theta5", "description", "events", "top_10_ev", "max_ev"))
#Indicate whether or not the exit velocity is in top 10 percent
combined_data <- combined_data %>%
mutate(top_10 = ifelse(is.na(top_10), "No", top_10)) %>%
filter(launch_angle > -40) %>%
mutate(events = ifelse(events == "", "foul", events))
#Create a quadratic regression for top 10 percent data
top_10_data$launch_angle2 = top_10_data$launch_angle^2
quadratic_fit <- lm(scaled_ev ~ launch_angle + launch_angle2, data = top_10_data)
#Scatter plot data differentiating the events by color and indicating the maximum predicted value for the launch angle that gives the max exit velocity using the quadratic regression
ggplot(combined_data) +
geom_point(aes(launch_angle, scaled_ev, color = events)) +
stat_smooth(method = "lm", formula = y ~ x + I(x^2), data = top_10_data, aes(launch_angle, scaled_ev), color = "black", se = FALSE) +
geom_vline(aes(xintercept = top_10_data$launch_angle[which.max(predict(quadratic_fit))]), linetype = "dashed") +
ggtitle(paste("Exit Velocity vs Launch Angle of", "Shohei, Ohtani")) +
scale_x_continuous(name = "Launch Angle (deg)", breaks = seq(-40, 80, by = 10)) +
scale_y_continuous(name = "Scaled Exit Velocity (mph)", breaks = seq(0.4, 1.2, by = 0.2)) +
annotate(geom = "text", label = top_10_data$launch_angle[which.max(predict(quadratic_fit))], x = top_10_data$launch_angle[which.max(predict(quadratic_fit))], y = 1.2, vjust = 1)
}
plot_events_ev_vs_la("Ohtani, Shohei")
ggplot(q_df, aes(launch_angle, batting_average_for_BIP, label = hitter)) + geom_point() + geom_smooth() +
geom_label_repel() + xlab("Launch Angle that Gives Maximum Exit Velocity") + ylab("Batting Average for BIP")
summary(SimpleGBMModel2)
gbm_auc_testing2
summary(SimpleGBMModel2)
summary(SimpleGBMModel)
